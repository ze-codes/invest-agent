<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Indicator Visualization</title>
    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        margin: 16px;
        padding-top: 56px; /* space for fixed top menu */
        padding-right: 400px; /* reserve space for right sidebar chat */
      }
      #controls {
        margin-bottom: 12px;
      }
      #chart {
        width: 100%;
        height: 80vh;
      }
      input[type="text"] {
        width: 560px;
      }
      /* Loading overlay */
      #loading_overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }
      #loading_box {
        background: #fff;
        border: 1px solid #ddd;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        font-size: 14px;
        color: #333;
      }
      .spinner {
        width: 18px;
        height: 18px;
        border: 2px solid #ccc;
        border-top-color: #333;
        border-radius: 50%;
        display: inline-block;
        animation: spin 0.9s linear infinite;
        vertical-align: middle;
        margin-right: 8px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="top_nav"></div>
    <h2>Indicator Visualization</h2>
    <div id="controls">
      <form id="form">
        <input type="hidden" id="ids" value="" />
        <label>horizon:</label>
        <input type="text" id="horizon" value="1w" />
        <label>days:</label>
        <input type="number" id="days" value="180" min="7" max="2000" />
        <label>k:</label>
        <input type="number" id="k" value="12" min="1" max="64" />
        <button type="submit">Load</button>
      </form>
      <div id="legend_controls" style="margin-top: 8px">
        <button type="button" id="btn_select_all">Select all</button>
        <button type="button" id="btn_deselect_all">Deselect all</button>
      </div>
      <div id="recompute_controls" style="margin-top: 8px">
        <button type="button" id="btn_recompute">Recompute history</button>
      </div>
    </div>
    <div id="status" style="margin: 8px 0; color: #555"></div>
    <div id="chart"></div>
    <div id="loading_overlay">
      <div id="loading_box">
        <span class="spinner"></span><span id="loading_text">Loading…</span>
      </div>
    </div>
    <h3>Indicator details</h3>
    <div id="ind_details"></div>
    <h3>Docs</h3>
    <div id="ind_docs"></div>
    <h3>Bucket details</h3>
    <div id="bucket_details"></div>
    <!-- LLM brief and ask sections now provided via floating widget -->
    <script>
      function showLoading(message) {
        const ov = document.getElementById("loading_overlay");
        const txt = document.getElementById("loading_text");
        if (txt && message) txt.textContent = message;
        ov.style.display = "flex";
      }
      function hideLoading() {
        const ov = document.getElementById("loading_overlay");
        ov.style.display = "none";
      }
      function getQueryParam(name) {
        const url = new URL(window.location.href);
        return url.searchParams.get(name);
      }

      async function getDefaultIds() {
        const override = getQueryParam("ids");
        if (override) return override;
        try {
          const reg = await fetch("/indicators").then((r) => r.json());
          const ids = (reg || []).map((r) => r.id);
          if (ids && ids.length) return ids.join(",");
        } catch {}
        return "net_liq,reserves_w,tga_delta,rrp_delta,bill_rrp,ofr_liq_idx";
      }

      function getDefaultHorizon() {
        return getQueryParam("horizon") || "1w";
      }

      function getDefaultDays() {
        return parseInt(getQueryParam("days") || "180");
      }

      (async function presetIds() {
        document.getElementById("ids").value = await getDefaultIds();
      })();
      document.getElementById("horizon").value = getDefaultHorizon();
      document.getElementById("days").value = String(getDefaultDays());

      async function fetchIndicator(id, horizon, days) {
        const url =
          "/indicators/" +
          encodeURIComponent(id) +
          "/history?horizon=" +
          encodeURIComponent(horizon) +
          "&days=" +
          String(days);
        const r = await fetch(url);
        if (!r.ok) throw new Error("Failed to fetch " + id + " history");
        return r.json();
      }

      async function fetchSnapshot(horizon, k) {
        const url =
          "/snapshot?horizon=" +
          encodeURIComponent(horizon) +
          "&k=" +
          String(k);
        const r = await fetch(url);
        if (!r.ok) throw new Error("Failed to fetch snapshot");
        return r.json();
      }

      function statusNum(s) {
        if (s === "+1") return 1;
        if (s === "-1") return -1;
        return 0;
      }

      async function load(idsCsv, horizon, days) {
        showLoading("Loading data…");
        const ids = idsCsv
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);
        const traces = [];
        let registryDocs = { indicators: {} };
        try {
          const reg = await fetch("/indicators").then((r) => r.json());
          const regById = Object.fromEntries(reg.map((r) => [r.id, r]));
          const detailRows = [];
          try {
            const qs = encodeURIComponent(ids.join(","));
            registryDocs = await fetch(
              "/docs/registry_explainer?indicators=" + qs
            ).then((r) => r.json());
            console.log(registryDocs);
          } catch (e) {
            console.warn("docs fetch failed", e);
          }
          for (const id of ids) {
            try {
              const js = await fetchIndicator(id, horizon, days);
              const x = js.items.map((p) => p.as_of);
              const val = js.items.map((p) => p.value_numeric);
              const status = js.items.map((p) => statusNum(p.status));
              traces.push({
                x: x,
                y: val,
                mode: "lines",
                name: id,
                yaxis: "y",
              });
              traces.push({
                x: x,
                y: status,
                mode: "lines",
                name: id + " (status)",
                yaxis: "y2",
                line: { dash: "dot" },
              });
              const latest = js.items[js.items.length - 1] || {};
              const meta = regById[id] || {};
              detailRows.push(
                "<tr>" +
                  "<td><code>" +
                  id +
                  "</code></td>" +
                  "<td>" +
                  (meta.name || "") +
                  "</td>" +
                  "<td>" +
                  (meta.category || "") +
                  "</td>" +
                  "<td>" +
                  (meta.directionality || "") +
                  "</td>" +
                  "<td>" +
                  (meta.scoring || "") +
                  "</td>" +
                  "<td>" +
                  (meta.trigger_default || "") +
                  "</td>" +
                  "<td>" +
                  ((latest.value_numeric ?? "").toLocaleString?.() ||
                    (latest.value_numeric ?? "")) +
                  "</td>" +
                  "<td>" +
                  (latest.status || "") +
                  "</td>" +
                  "</tr>"
              );
            } catch (e) {
              console.error(e);
            }
          }

          // Add continuous regime score history as a trace
          try {
            const hr = await fetch(
              "/snapshot/history?horizon=" +
                encodeURIComponent(horizon) +
                "&days=" +
                String(days)
            );
            if (hr.ok) {
              const hist = await hr.json();
              const hx = (hist.items || []).map((it) => it.as_of);
              const hy = (hist.items || []).map((it) => {
                const reg = it.regime || {};
                return reg.score_cont != null ? reg.score_cont : reg.score;
              });
              traces.push({
                x: hx,
                y: hy,
                mode: "lines",
                name: "score_cont",
                yaxis: "y2",
                line: { color: "#222", width: 3 },
              });
            }
          } catch (e) {
            console.warn("score_cont history fetch failed", e);
          }
          const layout = {
            title: ids.join(", "),
            xaxis: { type: "date" },
            yaxis: { rangemode: "tozero", title: "value_numeric" },
            yaxis2: {
              rangemode: "tozero",
              overlaying: "y",
              side: "right",
              title: "status (-1..+1)",
            },
            legend: { orientation: "h" },
          };
          Plotly.newPlot("chart", traces, layout, { responsive: true });
          document.getElementById("ind_details").innerHTML =
            '<table border="1" cellpadding="6" cellspacing="0">' +
            "<thead><tr>" +
            "<th>indicator_id</th><th>name</th><th>category</th><th>directionality</th><th>scoring</th><th>trigger</th><th>latest_value</th><th>latest_status</th>" +
            "</tr></thead><tbody>" +
            detailRows.join("") +
            "</tbody></table>";
        } finally {
          hideLoading();
        }

        // Bucket details table from snapshot
        try {
          const k = parseInt(document.getElementById("k").value) || 12;
          const snap = await fetchSnapshot(horizon, k);
          const buckets = snap.bucket_details || [];
          const rows = buckets.map((b) => {
            const members = (b.members || [])
              .map(
                (m) => `${m.id}(${m.status}${m.is_representative ? "*" : ""})`
              )
              .join(", ");
            return (
              "<tr>" +
              `<td><code>${b.bucket_id}</code></td>` +
              `<td>${b.category ?? ""}</td>` +
              `<td>${b.weight ?? 0}</td>` +
              `<td>${b.aggregate_status}</td>` +
              `<td><code>${b.representative_id ?? ""}</code></td>` +
              `<td>${members}</td>` +
              "</tr>"
            );
          });
          document.getElementById("bucket_details").innerHTML =
            '<table border="1" cellpadding="6" cellspacing="0">' +
            "<thead><tr>" +
            "<th>bucket_id</th><th>category</th><th>weight</th><th>aggregate_status</th><th>representative</th><th>members (status; *rep)</th>" +
            "</tr></thead><tbody>" +
            rows.join("") +
            "</tbody></table>";
        } catch (e) {
          console.warn("bucket details render failed", e);
        }
        const docBlocks = ids
          .map(function (id) {
            const indDocs = (registryDocs && registryDocs.indicators) || {};
            const d = indDocs[id] || {};
            if (!d.title && !d.why) return "";
            return (
              '<div style="margin:12px 0;">' +
              "<h4><code>" +
              id +
              "</code> — " +
              (d.title || "") +
              "</h4>" +
              (d.why
                ? "<div><strong>Why it matters:</strong> " + d.why + "</div>"
                : "") +
              (d.trigger
                ? "<div><strong>Trigger:</strong> " + d.trigger + "</div>"
                : "") +
              (d.directionality
                ? "<div><strong>Directionality:</strong> " +
                  d.directionality +
                  "</div>"
                : "") +
              "</div>"
            );
          })
          .join("");
        const docsHost = document.getElementById("ind_docs");
        docsHost.innerHTML = docBlocks;
      }

      async function generateBrief(horizon) {
        const statusEl = document.getElementById("brief_status");
        const outEl = document.getElementById("brief_md");
        try {
          statusEl.textContent = "Generating brief…";
          outEl.textContent = "";
          const k = parseInt(document.getElementById("k").value) || 12;
          const r = await fetch(
            "/llm/brief?horizon=" +
              encodeURIComponent(horizon) +
              "&k=" +
              String(k),
            { method: "POST" }
          );
          if (!r.ok) throw new Error("brief failed");
          const js = await r.json();
          outEl.textContent = js.markdown || "";
          statusEl.textContent = "";
        } catch (e) {
          console.warn(e);
          statusEl.textContent = "Brief failed.";
        }
      }

      function askLLMStream(question, horizon) {
        const statusEl = document.getElementById("ask_status");
        const ansEl = document.getElementById("ask_answer");
        const evEl = document.getElementById("ask_events");
        const panel = document.getElementById("ask_stream_panel");
        const showThinking =
          document.getElementById("chk_show_thinking").checked;
        if (!question || !question.trim()) return;
        panel.style.display = "block";
        ansEl.textContent = "";
        evEl.textContent = "";
        statusEl.textContent = "Streaming…";
        const url =
          "/llm/ask_stream?question=" +
          encodeURIComponent(question) +
          "&horizon=" +
          encodeURIComponent(horizon);
        const es = new EventSource(url);
        es.addEventListener("thinking_token", (e) => {
          if (!showThinking) return;
          try {
            const d = JSON.parse(e.data);
            evEl.textContent += d.text || "";
          } catch {}
        });
        es.addEventListener("answer_token", (e) => {
          try {
            const d = JSON.parse(e.data);
            ansEl.textContent += d.text || "";
          } catch {}
        });
        es.addEventListener("start", (e) => {
          try {
            evEl.textContent += "start " + e.data + "\n";
          } catch {}
        });
        es.addEventListener("decision", (e) => {
          try {
            evEl.textContent += "decision " + e.data + "\n";
          } catch {}
        });
        es.addEventListener("tool_call", (e) => {
          try {
            evEl.textContent += "tool_call " + e.data + "\n";
          } catch {}
        });
        es.addEventListener("tool_result", (e) => {
          try {
            evEl.textContent += "tool_result " + e.data + "\n";
          } catch {}
        });
        es.addEventListener("final", (e) => {
          try {
            const d = JSON.parse(e.data);
            if (!ansEl.textContent) ansEl.textContent = d.answer || "";
          } catch {
            ansEl.textContent = e.data || "";
          }
          statusEl.textContent = "";
          es.close();
        });
        es.onerror = () => {
          statusEl.textContent = "Stream error.";
          es.close();
        };
      }

      function setStatus(msg) {
        const el = document.getElementById("status");
        if (el) el.textContent = msg || "";
      }

      async function recomputeHistory(horizon, days) {
        try {
          showLoading(
            `Recomputing ${horizon} indicator history for last ${days} days…`
          );
          const k = parseInt(document.getElementById("k").value) || 12;
          const url =
            "/events/backfill_history?horizon=" +
            encodeURIComponent(horizon) +
            "&days=" +
            String(days) +
            "&k=" +
            String(k) +
            "&as_of_mode=obs";
          const r = await fetch(url, { method: "POST" });
          if (!r.ok) throw new Error("backfill failed");
          const js = await r.json();
          setStatus(
            `Recompute done (persisted ${js.persisted || 0}); loading charts…`
          );
        } catch (e) {
          console.warn("recompute failed", e);
          setStatus("");
        } finally {
          hideLoading();
        }
      }

      function setAllTracesVisible(visible) {
        const gd = document.getElementById("chart");
        const n = gd && gd.data ? gd.data.length : 0;
        if (!n) return;
        const indices = Array.from({ length: n }, (_, i) => i);
        const vis = visible ? true : "legendonly";
        Plotly.restyle(gd, { visible: vis }, indices);
      }

      document.getElementById("form").addEventListener("submit", function (ev) {
        ev.preventDefault();
        const ids = document.getElementById("ids").value;
        const h = document.getElementById("horizon").value || "1w";
        const d = parseInt(document.getElementById("days").value) || 180;
        (async () => {
          await load(ids, h, d);
          await generateBrief(h);
          setStatus("");
        })();
      });

      // Manual recompute trigger
      document
        .getElementById("btn_recompute")
        ?.addEventListener("click", function () {
          const ids = document.getElementById("ids").value;
          const h = document.getElementById("horizon").value || "1w";
          const d = parseInt(document.getElementById("days").value) || 180;
          (async () => {
            await recomputeHistory(h, d);
            await load(ids, h, d);
            await generateBrief(h);
            setStatus("");
          })();
        });

      document
        .getElementById("btn_brief")
        ?.addEventListener("click", function () {
          const h = document.getElementById("horizon").value || "1w";
          generateBrief(h);
        });

      document
        .getElementById("btn_ask_stream")
        ?.addEventListener("click", function () {
          const q = document.getElementById("ask_q").value || "";
          const h = document.getElementById("horizon").value || "1w";
          askLLMStream(q, h);
        });

      // Submit question on Enter (Shift+Enter inserts newline)
      document
        .getElementById("ask_q")
        ?.addEventListener("keydown", function (ev) {
          if (ev.key === "Enter" && !ev.shiftKey) {
            ev.preventDefault();
            const q = document.getElementById("ask_q").value || "";
            const h = document.getElementById("horizon").value || "1w";
            askLLMStream(q, h);
          }
        });

      document
        .getElementById("btn_select_all")
        ?.addEventListener("click", function () {
          setAllTracesVisible(true);
        });
      document
        .getElementById("btn_deselect_all")
        ?.addEventListener("click", function () {
          setAllTracesVisible(false);
        });

      async function backfillLightweight(horizon, days, k) {
        try {
          const url =
            "/events/backfill_history?horizon=" +
            encodeURIComponent(horizon) +
            "&days=" +
            String(days) +
            "&k=" +
            String(k) +
            "&as_of_mode=obs";
          await fetch(url, { method: "POST" });
        } catch (e) {
          // non-fatal
        }
      }

      (async function init() {
        let ids = document.getElementById("ids").value;
        if (!ids) {
          // Ensure IDs are populated before initial load to avoid race with presetIds
          ids = await getDefaultIds();
          document.getElementById("ids").value = ids;
        }
        const h = document.getElementById("horizon").value || "1w";
        const d = parseInt(document.getElementById("days").value) || 180;
        const k = parseInt(document.getElementById("k").value) || 12;
        // kick off lightweight backfill (non-blocking)
        backfillLightweight(h, d, k);
        showLoading("Loading data…");
        await load(ids, h, d);
        hideLoading();
        setStatus("");
      })();
    </script>
  </body>
  <script src="/static/common_nav.js"></script>
  <script src="/static/chat_widget.js"></script>
</html>
